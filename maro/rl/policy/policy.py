# Copyright (c) Microsoft Corporation.
# Licensed under the MIT license.

from abc import ABC, abstractmethod

from maro.rl.algorithms import AbsAlgorithm
from maro.rl.experience import ExperienceSet, ExperienceStore, UniformSampler


class AbsPolicy(ABC):
    """Abstract policy class."""
    def __init__(self):
        super().__init__()

    @abstractmethod
    def choose_action(self, state):
        raise NotImplementedError


class NullPolicy(AbsPolicy):
    """Dummy policy that does nothing.

    Note that the meaning of a "None" action may depend on the scenario.
    """
    def choose_action(self, state):
        return None


class CorePolicy(AbsPolicy):
    """Policy that can update itself using simulation experiences.

    Reinforcement learning (RL) policies should inherit from this.

    Args:
        algorithm (AbsAlgorithm): Algorithm instance.
        experience_memory (ExperienceStore): An ``ExperienceStore`` instance for storing and retrieving experiences
            generated by the policy.
        experience_sampler_cls: Type of experience sampler. Must be a subclass of ``AbsSampler``. Defaults to
            ``UnifromSampler``.
        experience_sampler_kwargs (dict): Keyword arguments for ``experience_sampler_cls``.
        num_epochs (int): Number of times ``self.algorithm.learn()`` is called in each call to ``update``. Defaults
            to 1.
    """
    def __init__(
        self,
        algorithm: AbsAlgorithm,
        experience_memory: ExperienceStore,
        experience_sampler_cls=UniformSampler,
        experience_sampler_kwargs: dict = {}
    ):
        super().__init__()
        self.algorithm = algorithm
        self.experience_memory = experience_memory
        self.sampler = experience_sampler_cls(self.experience_memory, **experience_sampler_kwargs)
        self.exploring = False
        self._update_index = 0

    def choose_action(self, state):
        return self.algorithm.choose_action(state, explore=self.exploring)

    def store_experiences(self, exp: ExperienceSet) -> bool:
        """
        Store incoming experiences and update if necessary.
        """
        self.experience_memory.put(exp)
        # print(
        #     f"exp mem size = {self.experience_memory.size}, incoming: {exp.size}, new exp = {self._new_exp_counter}"
        # )

    def reset_memory(self):
        """Clear the experience store."""
        self.experience_memory.clear()

    def update(self, grad=None):
        if grad:
            self.algorithm.apply(grad)
        else:
            self.algorithm.learn(self.sampler.get())

        self._update_index += 1
        self.algorithm.post_update(self._update_index)

    def explore(self):
        self.exploring = False

    def exploit(self):
        self.exploring = True

    def exploration_step(self):
        if self.algorithm.exploration:
            self.algorithm.exploration.step()
